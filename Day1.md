==**第一章：概述以及简介**==


	1.软件由程序+数据+文档组成
	
	2.软件开发基本的生命周期包括计划-分析-设计-实现-测试与集成-维护

	3.开发基本模型，后续用到了再说
	
	4.**面向对象的概念**：区别于以往的面向过程开发，具有三大优势，封装，继承，多态，形象地讲，对于“人”这一种生物，面向过程开发有点像面向具体一个人比如张三李四，围绕他的衣食起居进行描述，面向对象开发则是对“人”这一种“类”进行描述，人具有一些属性，比如身高、体重、血糖等，人还具有一些行为也叫方法，比如吃饭，运动等，这都是人这一个大类具有的特点，在此基础上，可以延伸出女人，男人，残疾人等一些出自“人”的类，叫作子类，子类可以继承父类的特点，比如残疾人也有身高，体重，也要吃饭，子类还可以改写来自父类的方法，比如残疾人运动肯定和正常人不一样，需要改写，子类还可以延伸出新的特点，比如说他可能多长了一个什么器官之类的。这些都是抽象的对象，叫作“人”，如果想要具体地获取谁谁谁，那么将其实例化即可，赋予一些确定的属性（身高，体重）。
	
	5.面向对象三大优势，封装，多态以及继承。后续遇见了再剖析
	-封装：私有对象的属性，公开对象的方法，只给外界展示可以看到的，具体的细节不希望外界访问，提高安全性以及简化编程
	-继承：子类可以继承父类，实现代码复用，简化编程
	-多态：同一个行为，同一个接口但是不同的实现。
	
	6.JAVA语言，不详细讲，实践时再说


**==第二章：JAVA语言基础==**
JAVA有点像C++，没细看两者渊源，治学有点不严谨了，本章不讲太详细，和C++很多一样的地方

	1.标识（zhi四声）符：用来给变量(不一定是变量，这里是方便理解）命名的，比如说张三的身高一米八，创建一个整数类型的变量命名为height，再把一米八赋给height。为了维护代码可读性，建议遵守以下命名规则
	-单个单词命名的全用小写，多个单词那么首单词小写，后续的首字母大写，比如getName
	-标识符不能和关键字（被赋予了特殊意义的词）一样，比如if，while之类的
	-常量的名字要全部大写，比如说张三身高设成了常量（程序运行过程中全程保持不变的量），那么就取名HEIGHT。
	-类的名字要首字母全大写，比如我创建了一个类PlayerCharacter
	
	2.关键字，不详细讲了，实践时用多了就记住了，记不住的证明不常用，需要的时候再看就行
	(https://blog.csdn.net/weixin_44893902/article/details/105204049)

	3.基本数据类型，和C++有一些不一样
	-整数类型的byte，short，int，long，区别在于范围，计算机是二进制的机器，有四个位置用来给01进行不同的组合表达，范围肯定就比两个位置用来表达得更多
	-浮点数类型有float，double，可以用带小数点的数来理解但是二者并不相同，同样的，两个类型区别在于表达范围
	-字符型char，就是用来放键盘上这些字符的，比如a，b，c，d这些字母或者！等一些符号
	-布尔型boolean，这个和C++区别很大，C++的布尔值是bool，布尔值只有两个值，一个是true，一个是false，表示真假，比如我用两个数比大小，a<b，a小于b吗，如果小于那这个式子带来的结果是true，否则是false
	-引用型，class表示类，interface表示接口，[]表示数组，这个后面不作详细解释，实践的时候一眼就看明白了
	-非引用型的数据想要转换，只能从高精度的往低精度的转，比如说long可以转到int，int不能转到long，原因很简单，long有八个字节可以用来表示数字大小，int只有四个，八个转到四个，会造成缺失

	4.常量与变量，变量刚才说得七七八八了，不再说了，常量就是运行过程中不改变的量，常量在定义时有对应格式
	-要求：[修饰符] final 常量名=常量，其中修饰符有四种public，private，protected，无，后面详细讲,其中，常量名和final之间还可以选择是否加入static，static表示你这一个程序只有这个常量叫这个名字，你在其他任何地方都不许再定义一个这个名字的常量了
	-例子：public final static double PI=3.1415926;//定义了一个PI表示圆周率并且全程序唯一

	5.控制流程，这个和C++区别不大，简单讲一讲
	-if，if(条件判断语句)，如果括号里的语句结果判断为真，那么就执行if框选里的内容，否则就跳过该if执行后面的内容了
	-else if(条件判断语句)或者else，这个通常接到if语句后面，表示如果不是刚才那样的判断，那么就是这个判断，本质上就是个if，但是else if多个判断，else语句不需要判断
	-switch,分支判断，相当于多个if组合起来，switch(),根据括号里的内容的值选择不同的分支进行
	-while循环，顾名思义while(),当括号里的内容为真时不停地执行while框选的内容，直到括号里的内容不再为真
	-do while循环，就是while循环反过来，先执行框选内容再在while的括号里进行判断
	-for循环，for循环一般来说格式为for( ; ; ),第一个空白处通常展示变量一开始是什么模样，第二个空白处是要去执行框选内容时需要满足的条件，第三个空白处一般是变量自己的变化，这里很抽象，以后遇见实际例子就明白了
	-跳出循环一般有三个关键字，break，continue和return，其中break是直接跳出循环，不做循环了，continue是跳过该次循环时后面的内容从而进入到下次循环，return是直接返回了，这个函数就到此为止了

	6.输入与输出，这是我觉得java相对比C++又臭又长的地方,输入就是读取用户输入的东西，输出就是在屏幕上打印东西，同样，后续实例的时候就明白了
	-标准输入，System.in
	-标准输出，System.out

	7.数组，这是我觉得和C++差异最大的地方，Java是没有指针的，所以初次接触数组时很别扭，但是正因为没有指针，功能减少了但是变得很简单了
	-数组就是一组数，就好比登记学生成绩，平时设置一个整型变量用来装张三的成绩，但是我现在要统计全班的成绩，那我只能创建整整一组整型变量来装这些人的成绩，为了减少工作，就不要一个一个去创建了，而是直接创建一个组的空间来容纳每个数，同样为了区分，数组有索引，就好比学号，在一张成绩单上，1号同学成绩是巴拉巴拉，2号同学成绩是巴拉巴拉。
	-数组声明方式，一种是Java风格int[] a，还有一种是C风格int a[]
	-数组创建方式，一种是int[] a=new int[2];//这种方式意味着我要创建一个容纳两个元素的数组
	还有一种是int[] a=new int[]{1,2};//这种方式意味着我直接规划好了第一个元素是1，第二个元素是2，数组一旦创建完毕，元素个数就没法改变了，因为本质上是在内存中开辟的一块空间，开辟好了就不能改了，不然牵一发而动全身。
	-想用数组的内容的话就直接用a[1]就好了，这个就表示该数组的第二个元素，本质上就是个整型变量，当然数组的索引是从0开始到n-1结束，也就是0对于第一个元素，n-1对应最后一个元素

	8.异常，虚拟机，这些不作解释，目前没有需求，若有需求，再说


**==第三章：类和对象==**

	1.面向对象这一思想引入目的是降低代码耦合度，增加复用度和扩展性，后续所有的设计模式都离不开这一思想

	2.类和对象的区别，类是抽象的，“人类”是一个类，对象是具体的，“张三”“李四”都是对象，类其实就是对象的一个模板，对象是具体的实现，类是静态的，你在程序执行前，类就已经定义完了，对象是动态的，在执行过程中，对象被创建，变化然后结束生命周期

	3.类的声明
	public class Person
	{
		private int age;
		
		Person(int age)
		{
			this.age=age;
		}
		
		public int getAge()
		{
			return age;
		}
	}
	这一段声明了一个类class叫Person，Person里面声明了一个属性叫作age，还有一个方法getAge，其中age是私有的private不希望外界来访问age，getAge是共有的，外界可以来使用这个方法来获取对象的age，这体现了封装性，对于这些属性啊，设为私有，那么就可以通过set和get方法来进行对该属性的更改和获取

	4.构造方法，用来初始化类里的一些属性，在C++里面类只要创建就会有构造方法，你自己不写的话编译的时候也会给你默认搞一个
	-构造方法是类的名字作为函数名，没有返回值，如上所示，括号里的内容是创建对象的时候用户自己输入的东西，this.age=age是赋值，把用户输的东西赋给对象的age属性，为了表示二者的区分度，加入了this关键字意思该对象的属性而不是输入的那个数据
	
	5.子类与父类，子类可以继承自父类，用例子来说明
		public class Student extends Person
		{
			super(age);
			String school;
			String getSchool()
			{
				...
			}
		}
		这里extends关键字表示继承关系，Person是Student的父类，super表示该子类继承父类的age属性，引入新的属性是字符串类型的school
		
	6.访问权限的关键字刚才说了有四种
	-public：到处都可以访问
	-private：不能被其它类访问
	-protected：可以被子类以及子类的子类访问
	-无（默认）：可以被同一个包里的访问，包就是软件包，有点像文件夹的意思

	7.多维数组，和C++有点不一样，多维数组是数组里套数组而不是C++那样的矩阵形式，多维数组有三种初始化形式
	-int[][] a=new int[m][n];//表示这个数组有m个一维数组，每个一维数组有n个元素
	-int[][] a=new int[m][];//这个数组有m个一维数组，每个一维数组为空，还没想好一维数组里面是什么，这个时候可以分别进行初始化，a[0]=new int[1]
	-int[][] a=new int[][n]该操作非法
	-int[][] a=new int[][]{{123},{1},{2}};//静态初始化，直接赋值好了，由此可见不是Java的多维数组不是严格矩阵式的



**==第四章==**：继承

	1.如前文所讲，编程要优化的三个方面：扩展性，耦合度，复用度。继承可以极大程度上优化复用度，用前面关于Student和Person类的例子来说，如果子类Student不继承Person的age，而是自己另起炉灶搞一个age，那本质一样的属性又搞一遍，浪费开销，所以继承很有必要。
	
	2.子类通过extends继承父类，可以继承属性，但是不能继承构造方法，需要用super关键字来继承构造方法，前文有展示，在继承的基础上，子类还可以对属性和方法进行改写。
	
	3.延伸出一个思考，子类继承父类，如果父类里的东西改了，那子类也得改，增加了代码耦合度，这不是我们希望的，所以引出了抽象类，关键字是abstract，比如public abstract class Person,创建了一个抽象类，抽象类存在的目的是，我希望有这么一个具有共通点的东西做父类，但是父类里面的具体实现我还没想好，我就把它留着等着后续继承的子类来实现。在抽象类里面有两类方法，一类是普通的，该怎么办就怎么办，另一类是抽象的，同样加入abstract关键字修饰，父类不做定义，留给子类自己去实现，仅仅只是占个位而已。抽象类最重要的特点是不能实例化，没办法new一个对象出来

	4.接口（interface），比抽象类更抽象，接口内部没有普通方法，全是抽象方法，那就不使用extends了，取而代之的是implements。

	5.多态的实现：多态实现很重要，有的时候方法往往在执行时才能被确定要干嘛，举个例子，张三的一个方法“吃饭”，吃饭的输入可能是干的，可能是稀的，为了针对这种情况实现多态，在不同情况下做出不同表现
	-(1):使用@Override对子类进行父类方法的重写，写法很简单，就是在子类对应的方法前面加上这个关键字，然后就可以去重写该方法
	-(2):抽象类，父类对方法的实现留白，放手发动子类自己去实现
	-(3):接口，同上就不说了。

	6.多继承，超类等...目前不涉及，我主要重心也不是Java，等以后有必要再说。



**==第五章==**：设计模式


	1.前面讲的三点优化：耦合度要低，扩展性和复用性要好，这都是思想，思想具体落实下来就叫模式。具体设计模式七大原则，这里照本宣科一下，后续根据具体案例进行分析
	-单一职责原则：一个类应当负责单一的一项职责，他只能因为一个原因而变化，有点像定义了一个服务员的类，我希望这个服务员负责端盘子就行了，这个服务员如果还承担擦桌子这个职责的话，那我极其有可能改变他端盘子的职责时改动到了他擦桌子的职责。具体实现有一定难度，但是要尽可能去追求。
	-开闭原则：对修改关闭，对扩展开放，在具体更改一个模块的时候希望是通过扩展的方式而不是在模块内部大刀阔斧地改动。后续有案例便于理解
	-里氏代换原则：软件在使用基类的时候一定适用于其子类，而且察觉不出来两者的区别，反之不成立。很抽象的概念，但是要求不是很高，有要求再说。
	-依赖倒转原理：高层模块和低层模块不互相依赖，他们都要依赖抽象，要针对接口编程
	-合成/聚合复用原则
	-接口隔离原则
	-迪米特原则

	2.设计模式四要素：模式名，问题，解决方案，效果。分为创建型，结构型，行为型，全是背诵内容较为无聊，想了解可以自行搜索，接下来讲具体设计模式。

	3.单例模式，单例模式适用的地方是有一个对象，他在全程序里只有他自己一个，依旧举例子，有一个人叫“张三”，我不希望他在上学时被创建出来完成一系列任务，在运动比赛的时候又被创建出来完成一系列任务。全局都只有这么一个张三的人在忙前忙后，我希望在这些场景里用的是同样一个张三，他在创建出来之后就不再改动了，需要他的时候直接调来用而不是再创建增大开销。
	-饿汉式：在类的定义里面直接使用static关键字完成对象的创建，接着定义getInstance方法来给其他地方来调用该单例，这个方法来的很快，但是读程序读到你这个类的时候就完成了对象的创建，有没有方法进一步降低开销呢。
	-懒汉式：与饿汉式相比，懒汉式把对象的创建放在了getInstance方法里了，方法外面仅仅只是声明而已，这么做意思就是在调用这个getInstance时才会完成创建，不需要就不会创建，开销会小一点，但是有可能在多线程进行工作时，两个线程同时访问到了getInstance，有可能会保证不了只有一个该实例。
	-同步锁，与懒汉式相比，在方法名前面加一个synchronized关键字确保只有单线程在使用这段资源，这部分涉及操作系统知识，线程简而言之就是一种执行任务的管道，在执行这个任务就不能执行那个任务。
	
	4.工厂模式，原有的模式是什么样的，举个例子，还是张三这个人，他可能有一个方法是穿鞋，我不希望在张三这个类里面写一堆代码来表现张三要根据什么信息来抉择穿什么鞋，耦合度很高，如果又一个李四，他和张三穿鞋方法一样，我又在李四里面洋洋洒洒写一大堆，倘若一天我要改动这个方法，工作量很大。我希望张三这个类的穿鞋方法里面简单调用一个接口来完成穿鞋的任务，就算要改，我也是去顺着这个接口去改，增删改很方便。
	-首先要创建总工厂，它是一个抽象的接口，具体例子就举做披萨吧，总工厂里面设计抽象方法，创建披萨，具体实现交给子类
	-在这个接口的基础上创建子工厂，有点像车间，上面把作披萨的图纸传下来了，车间负责具体实现各种各样的披萨，实现做披萨的具体方法，在这些方法里才来决定实例化什么披萨。
	-外边的餐馆类，卖披萨的话就直接调用总工厂这个设计披萨的接口就行了，耦合度大大降低。
	-增删改全权交给工厂去完成，外面只管调用就行了。
	
	